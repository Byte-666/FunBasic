## You appear to be advocating a new...

 - [x] Functional
 - [ ] Imperative
 - [ ] Object-oriented 
 - [ ] Procedural
 - [ ] Stack-based
 - [ ] "Multi-paradigm"
 - [ ] Lazy 
 - [x] Eager
 - [x] Statically-typed
 - [ ] Dynamically-typed
 - [ ] Pure
 - [x] Impure
 - [ ] Non-hygienic
 - [ ] Visual
 - [x] Beginner-friendly
 - [ ] Non-programmer-friendly
 - [ ] Completely incomprehensible

...programming language.


## Your language will not work for the following reasons:

You appear to believe that:

 - [x] Syntax is what makes programming difficult
 - [x] Garbage collection is free
 - [x] Computers have infinite memory
 - [ ] Nobody really needs:
   - [ ] Concurrency
   - [ ] A REPL
   - [x] Debugger support
   - [x] IDE support  
   - [ ] I/O
   - [x] To interact with code not written in your language
 - [ ] The entire world speaks 7-bit ASCII
 - [x] Scaling up to large software projects will be easy
 - [ ] Convincing programmers to adopt a new language will be easy
 - [ ] Convincing programmers to adopt a language-specific IDE will be easy
 - [ ] Programmers love writing lots of boilerplate
 - [ ] Specifying behaviors as "undefined" means that programmers won't rely on them
 - [ ] "Spooky action at a distance" makes programming more fun


You don't appear to understand:

 - [ ] Basic optimization techniques
 - [ ] Basic systems programming
 - [ ] Pointers
 - [ ] Functions


Your language [(H)as/(L)acks/(O)ther/(U)nknown]:

 - [H] Comprehensible syntax
 - [L] Semicolons
 - [U] Significant whitespace
 - [L] Macros
 - [L] Implicit type conversion
 - [H] Explicit casting
 - [H] Type inference
 - [L] Goto
 - [L] Exceptions
 - [H] Closures
 - [H] Tail recursion
 - [L] Coroutines
 - [L] Reflection
 - [L] Subtyping
 - [L] Multiple inheritance
 - [L] Operator overloading
 - [H] Algebraic datatypes
 - [U] Recursive types
 - [U] Polymorphic types
 - [L] Covariant array typing
 - [O] Monads
 - [L] Dependent types
 - [L] Infix operators
 - [L] Nested comments
 - [L] Multi-line strings
 - [L] Regexes
 - [ ] Call-by:
   - [X] Value
   - [ ] Name
   - [ ] Reference
   - [ ] CC


The following philosophical objections apply:

 - [X] Programmers should not need to understand category theory to write "Hello, World!"
 - [X] Programmers should not develop RSI from writing "Hello, World!"
 - [X] The most significant program written in your language is its own compiler
 - [ ] The most significant program written in your language isn't even its own compiler
 - [X] No language spec
 - [ ] The implementation is:
   - [X] The spec
   - [ ] Closed-source
   - [ ] Covered by patents
   - [ ] Not owned by you
 - [ ] Your type system is unsound
 - [ ] Your language cannot be unambiguously parsed
   - [ ] A proof of same is attached
   - [ ] Invoking this proof crashes the compiler
 - [ ] The name of your language makes it impossible to find on Google
 - [ ] Interpreted languages will never be as fast as C
 - [ ] Compiled languages will never be "extensible"
 - [ ] Writing a compiler that understands English is AI-complete
 - [X] Your language relies on an optimization which has never been shown possible
 - [ ] There are less than 100 programmers on Earth smart enough to use your language
 - [X] Type-Inference takes exponential time
 - [ ] ____________________________ is known to be undecidable


Your implementation has the following flaws:

 - [ ] ____ do(es) not work that way:
   - [X] CPUs
   - [ ] RAM
   - [ ] VMs
   - [X] Compilers
 - [ ] Shift-reduce conflicts in parsing seem to be resolved using rand()
 - [X] You require the compiler to be present at runtime
 - [X] You require the language runtime to be present at compile-time
 - [ ] Your compiler errors are completely inscrutable
 - [ ] Dangerous behavior is only a warning
 - [X] The compiler crashes if you look at it funny
 - [X] The VM crashes if you look at it funny


Your marketing has the following problems:

 - Unsupported claims of:
   - [X] Increased productivity
   - [X] Greater "ease of use"
 - Obviously rigged benchmarks:
   - [ ] Graphics, simulation, or crypto benchmarks where your code just calls handwritten assembly through your FFI
   - [ ] String-processing benchmarks where you just call PCRE
   - [ ] Matrix-math benchmarks where you just call BLAS
 - Nobody really believes that your language is faster than:
   - [X] assembly
   - [ ] C
   - [X] FORTRAN
   - [ ] Java
   - [ ] Ruby
   - [ ] Prolog
 - Rejection of:
   - [ ] Orthodox programming-language theory without justification
   - [ ] Orthodox systems programming without justification
   - [ ] Orthodox algorithmic theory without justification
   - [ ] Basic computer science without justification

        
Taking the wider ecosystem into account, I would like to note that:

 - Your complex sample code would be far more compact in:
   - [X] HASKELL
   - [ ] Python
   - [X] Another language that out-shines yours: F#
 - We already have a(n):
   - [ ] Unsafe imperative language
   - [ ] Safe imperative OO language
   - [X] Safe statically-typed eager functional language (really? we need more of course)
 - You have reinvented a worse version of:
   - [X] Lisp
   - [X] F#
   - [ ] Javascript
   - [ ] Java
   - [ ] C++
   - [ ] PHP
   - [ ] Brainfuck, but non-ironically

In conclusion, this is what I think of you:

You have some interesting ideas, but this won't fly.
This is a bad language, and you should feel bad for inventing it.
Programming in this language is an adequate punishment for inventing it.
